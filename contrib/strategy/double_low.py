"""Double low convertible bond strategy plugin."""

from __future__ import annotations

from dataclasses import dataclass
from datetime import date, datetime
from typing import Any, Literal

from core.context import Context
from plugins.base import Plugin


@dataclass(slots=True)
class Signal:
    """Trading signal generated by strategy."""

    symbol: str
    direction: Literal["BUY", "SELL"]
    quantity: int | None = None
    price: float | None = None
    reason: str = ""


class DoubleLowStrategy(Plugin):
    """双低可转债策略。

    策略逻辑：
    1. 获取所有可转债数据
    2. 计算每只可转债双低值：``price + premium_rate * 100``
    3. 按双低值升序排序并选取 Top N
    4. 买入 Top N 中未持仓标的
    5. 卖出持仓中不在 Top N 的标的
    """

    name = "double_low"
    version = "1.0.0"

    top_n: int = 10
    min_volume: int = 1_000_000
    exclude_days_to_maturity: int = 30
    rebalance_days: int = 5

    def __init__(self) -> None:
        super().__init__()
        self._context: Context | None = None

    def setup(self, context: Context) -> None:
        """Bind runtime context."""
        self._context = context

    def teardown(self, context: Context) -> None:
        """Release runtime context reference."""
        _ = context
        self._context = None

    def on_init(self, context: Context) -> None:
        """Initialize strategy state in context storage."""
        context.set("double_low_initialized", True)
        context.set("double_low_last_rebalance_date", None)

    def on_bar(self, context: Context, bar: dict[str, Any]) -> list[Signal]:
        """Run strategy for one bar and return generated signals."""
        if not context.get("double_low_initialized", False):
            self.on_init(context)

        bar_date = self._coerce_date(bar.get("date"))
        last_rebalance = context.get("double_low_last_rebalance_date")
        if (
            isinstance(last_rebalance, date)
            and (bar_date - last_rebalance).days < self.rebalance_days
        ):
            return []

        cb_data = bar.get("cb_data", [])
        if not isinstance(cb_data, list):
            return []

        sorted_data = self.calculate_double_low(cb_data)
        top_codes = self.select_top_n(sorted_data)
        signals = self.generate_signals(context, top_codes)

        context.set("double_low_last_rebalance_date", bar_date)
        return signals

    def calculate_double_low(
        self, cb_data: list[dict[str, Any]]
    ) -> list[dict[str, Any]]:
        """计算双低值并过滤、排序。"""
        processed: list[dict[str, Any]] = []
        for row in cb_data:
            volume = int(float(row.get("volume", 0) or 0))
            days_to_maturity = int(float(row.get("days_to_maturity", 999999) or 999999))
            if volume < self.min_volume:
                continue
            if days_to_maturity <= self.exclude_days_to_maturity:
                continue

            price = float(row.get("price", 0.0) or 0.0)
            premium_rate = float(row.get("premium_rate", 0.0) or 0.0)

            item = dict(row)
            item["double_low"] = price + premium_rate * 100
            processed.append(item)

        processed.sort(key=lambda x: float(x["double_low"]))
        return processed

    def select_top_n(self, sorted_data: list[dict[str, Any]]) -> list[str]:
        """选取双低值最小的 Top N 可转债代码。"""
        selected: list[str] = []
        for row in sorted_data[: self.top_n]:
            symbol = str(row.get("symbol", ""))
            if symbol:
                selected.append(symbol)
        return selected

    def generate_signals(self, context: Context, top_codes: list[str]) -> list[Signal]:
        """基于目标池与当前持仓生成买卖信号。"""
        current_positions = set(context.portfolio.positions.keys())
        target_positions = set(top_codes)

        signals: list[Signal] = []

        for symbol in sorted(current_positions - target_positions):
            signals.append(
                Signal(symbol=symbol, direction="SELL", reason="Out of top N list")
            )

        for symbol in top_codes:
            if symbol not in current_positions:
                signals.append(
                    Signal(symbol=symbol, direction="BUY", reason="Enter top N list")
                )

        return signals

    @staticmethod
    def _coerce_date(value: Any) -> date:
        if isinstance(value, datetime):
            return value.date()
        if isinstance(value, date):
            return value
        if isinstance(value, str):
            for fmt in ("%Y-%m-%d", "%Y/%m/%d", "%Y%m%d"):
                try:
                    return datetime.strptime(value, fmt).date()
                except ValueError:
                    continue
        return date.today()
